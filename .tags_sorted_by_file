!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_PROGRAM_VERSION	5.8	//
LOCAL_INIT_RC	Android.mk	/^LOCAL_INIT_RC := servicemanager.rc$/;"	m
LOCAL_MODULE	Android.mk	/^LOCAL_MODULE := bctest$/;"	m
LOCAL_MODULE	Android.mk	/^LOCAL_MODULE := servicemanager$/;"	m
LOCAL_MODULE_TAGS	Android.mk	/^LOCAL_MODULE_TAGS := optional$/;"	m
LOCAL_PATH	Android.mk	/^LOCAL_PATH:= $(call my-dir)$/;"	m
LOCAL_SHARED_LIBRARIES	Android.mk	/^LOCAL_SHARED_LIBRARIES := liblog$/;"	m
LOCAL_SRC_FILES	Android.mk	/^LOCAL_SRC_FILES := bctest.c binder.c fuzz.c$/;"	m
LOCAL_SRC_FILES	Android.mk	/^LOCAL_SRC_FILES := service_manager.c binder.c$/;"	m
svc_c_flags	Android.mk	/^svc_c_flags =	\\$/;"	m
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
main	bctest.c	/^int main(int argc, char **argv)$/;"	f
svcmgr_lookup	bctest.c	/^uint32_t svcmgr_lookup(struct binder_state *bs, uint32_t target, const char *name)$/;"	f
svcmgr_publish	bctest.c	/^int svcmgr_publish(struct binder_state *bs, uint32_t target, const char *name, void *ptr)$/;"	f
token	bctest.c	/^unsigned token;$/;"	v
BIO_F_IOERROR	binder.c	/^#define BIO_F_IOERROR /;"	d	file:
BIO_F_MALLOCED	binder.c	/^#define BIO_F_MALLOCED /;"	d	file:
BIO_F_OVERFLOW	binder.c	/^#define BIO_F_OVERFLOW /;"	d	file:
BIO_F_SHARED	binder.c	/^#define BIO_F_SHARED /;"	d	file:
LOG_TAG	binder.c	/^#define LOG_TAG /;"	d	file:
MAX_BIO_SIZE	binder.c	/^#define MAX_BIO_SIZE /;"	d	file:
MAX_SERVICES	binder.c	/^#define MAX_SERVICES /;"	d	file:
NAME	binder.c	/^#define NAME(/;"	d	file:
TRACE	binder.c	/^#define TRACE /;"	d	file:
_bio_get_obj	binder.c	/^static struct flat_binder_object *_bio_get_obj(struct binder_io *bio)$/;"	f	file:
binder_acquire	binder.c	/^void binder_acquire(struct binder_state *bs, uint32_t target)$/;"	f
binder_call	binder.c	/^int binder_call(struct binder_state *bs,$/;"	f
binder_close	binder.c	/^void binder_close(struct binder_state *bs)$/;"	f
binder_done	binder.c	/^void binder_done(struct binder_state *bs,$/;"	f
binder_dump_txn	binder.c	/^#define binder_dump_txn(/;"	d	file:
binder_dump_txn	binder.c	/^void binder_dump_txn(struct binder_transaction_data *txn)$/;"	f
binder_link_to_death	binder.c	/^void binder_link_to_death(struct binder_state *bs, uint32_t target, struct binder_death *death)$/;"	f
binder_loop	binder.c	/^void binder_loop(struct binder_state *bs, binder_handler func)$/;"	f
binder_open	binder.c	/^struct binder_state *binder_open(size_t mapsize)$/;"	f
binder_parse	binder.c	/^int binder_parse(struct binder_state *bs, struct binder_io *bio,$/;"	f
binder_release	binder.c	/^void binder_release(struct binder_state *bs, uint32_t target)$/;"	f
binder_send_reply	binder.c	/^void binder_send_reply(struct binder_state *bs,$/;"	f
binder_state	binder.c	/^struct binder_state$/;"	s	file:
binder_write	binder.c	/^int binder_write(struct binder_state *bs, void *data, size_t len)$/;"	f
bio_alloc	binder.c	/^static void *bio_alloc(struct binder_io *bio, size_t size)$/;"	f	file:
bio_alloc_obj	binder.c	/^static struct flat_binder_object *bio_alloc_obj(struct binder_io *bio)$/;"	f	file:
bio_get	binder.c	/^static void *bio_get(struct binder_io *bio, size_t size)$/;"	f	file:
bio_get_ref	binder.c	/^uint32_t bio_get_ref(struct binder_io *bio)$/;"	f
bio_get_string16	binder.c	/^uint16_t *bio_get_string16(struct binder_io *bio, size_t *sz)$/;"	f
bio_get_uint32	binder.c	/^uint32_t bio_get_uint32(struct binder_io *bio)$/;"	f
bio_init	binder.c	/^void bio_init(struct binder_io *bio, void *data,$/;"	f
bio_init_from_txn	binder.c	/^void bio_init_from_txn(struct binder_io *bio, struct binder_transaction_data *txn)$/;"	f
bio_put_obj	binder.c	/^void bio_put_obj(struct binder_io *bio, void *ptr)$/;"	f
bio_put_ref	binder.c	/^void bio_put_ref(struct binder_io *bio, uint32_t handle)$/;"	f
bio_put_string16	binder.c	/^void bio_put_string16(struct binder_io *bio, const uint16_t *str)$/;"	f
bio_put_string16_x	binder.c	/^void bio_put_string16_x(struct binder_io *bio, const char *_str)$/;"	f
bio_put_uint32	binder.c	/^void bio_put_uint32(struct binder_io *bio, uint32_t n)$/;"	f
cmd_name	binder.c	/^const char *cmd_name(uint32_t cmd)$/;"	f
fd	binder.c	/^    int fd;$/;"	m	struct:binder_state	file:
get_all_handles	binder.c	/^void get_all_handles(struct binder_state *bs) {$/;"	f
get_handle_from_svcmgr	binder.c	/^static uint32_t get_handle_from_svcmgr(const uint16_t *str, binder_state *bs){$/;"	f	file:
get_random_handle	binder.c	/^void get_random_handle(struct binder_handle *ptr) {$/;"	f
handles	binder.c	/^static uint32_t handles[400];$/;"	v	file:
hexdump	binder.c	/^#define hexdump(/;"	d	file:
hexdump	binder.c	/^void hexdump(void *_data, size_t len)$/;"	f
mapped	binder.c	/^    void *mapped;$/;"	m	struct:binder_state	file:
mapsize	binder.c	/^    size_t mapsize;$/;"	m	struct:binder_state	file:
num_handles_set	binder.c	/^static uint32_t num_handles_set;$/;"	v	file:
services	binder.c	/^static uint16_t *services[400];$/;"	v	file:
verbose	binder.c	/^const int verbose = 0;$/;"	v
BINDER_SERVICE_MANAGER	binder.h	/^#define BINDER_SERVICE_MANAGER /;"	d
PING_TRANSACTION	binder.h	/^    PING_TRANSACTION  = B_PACK_CHARS('_','P','N','G'),$/;"	e	enum:__anon1
SVC_MGR_ADD_SERVICE	binder.h	/^    SVC_MGR_ADD_SERVICE,$/;"	e	enum:__anon1
SVC_MGR_CHECK_SERVICE	binder.h	/^    SVC_MGR_CHECK_SERVICE,$/;"	e	enum:__anon1
SVC_MGR_GET_SERVICE	binder.h	/^    SVC_MGR_GET_SERVICE = 1,$/;"	e	enum:__anon1
SVC_MGR_LIST_SERVICES	binder.h	/^    SVC_MGR_LIST_SERVICES,$/;"	e	enum:__anon1
SVC_MGR_NAME	binder.h	/^#define SVC_MGR_NAME /;"	d
TF_ACCEPT_FDS	binder.h	/^         TF_ACCEPT_FDS   = 0x10,$/;"	e	enum:transaction_flags
TF_ONE_WAY	binder.h	/^         TF_ONE_WAY      = 0x01,$/;"	e	enum:transaction_flags
TF_ROOT_OBJECT	binder.h	/^         TF_ROOT_OBJECT  = 0x04,$/;"	e	enum:transaction_flags
TF_STATUS_CODE	binder.h	/^         TF_STATUS_CODE  = 0x08,$/;"	e	enum:transaction_flags
_BINDER_H_	binder.h	/^#define _BINDER_H_$/;"	d
binder_death	binder.h	/^struct binder_death {$/;"	s
binder_handle	binder.h	/^struct binder_handle {$/;"	s
binder_handler	binder.h	/^typedef int (*binder_handler)(struct binder_state *bs,$/;"	t
binder_io	binder.h	/^struct binder_io$/;"	s
data	binder.h	/^    char *data;            \/* pointer to read\/write from *\/$/;"	m	struct:binder_io
data0	binder.h	/^    char *data0;           \/* start of data buffer *\/$/;"	m	struct:binder_io
data_avail	binder.h	/^    size_t data_avail;     \/* bytes available in data buffer *\/$/;"	m	struct:binder_io
flags	binder.h	/^    uint32_t flags;$/;"	m	struct:binder_io
func	binder.h	/^    void (*func)(struct binder_state *bs, void *ptr);$/;"	m	struct:binder_death
handle	binder.h	/^        uint32_t handle;$/;"	m	struct:binder_handle
offs	binder.h	/^    binder_size_t *offs;   \/* array of offsets *\/$/;"	m	struct:binder_io
offs0	binder.h	/^    binder_size_t *offs0;  \/* start of offsets buffer *\/$/;"	m	struct:binder_io
offs_avail	binder.h	/^    size_t offs_avail;     \/* entries available in offsets array *\/$/;"	m	struct:binder_io
ptr	binder.h	/^    void *ptr;$/;"	m	struct:binder_death
str	binder.h	/^        uint16_t *str;$/;"	m	struct:binder_handle
transaction_flags	binder.h	/^enum transaction_flags {$/;"	g
unused	binder.h	/^    uint32_t unused;$/;"	m	struct:binder_io
NO_HANDLE	fuzz.c	/^static const uint16_t NO_HANDLE[] = {'n','o','h','a','n','d','l','e','\\0'};$/;"	v	file:
bit_flip	fuzz.c	/^static void bit_flip(void *buffer, unsigned int length) {$/;"	f	file:
byte_flip	fuzz.c	/^static void byte_flip(void *buffer, unsigned int length) {$/;"	f	file:
byte_shift	fuzz.c	/^static void byte_shift(void *buffer, unsigned int length) {$/;"	f	file:
gen_transaction	fuzz.c	/^static void *gen_transaction(void) {$/;"	f	file:
generate_data_for	fuzz.c	/^void *generate_data_for(binder_command_type type) {$/;"	f
get_cookie	fuzz.c	/^static uint32_t get_cookie(void) {$/;"	f	file:
get_handle	fuzz.c	/^static uint32_t get_handle(struct binder_handle *ptr) {$/;"	f	file:
get_transaction_flags	fuzz.c	/^static int get_transaction_flags(void) {$/;"	f	file:
havoc_ints	fuzz.c	/^static int havoc_ints[] =$/;"	v	file:
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
LOG_TAG	service_manager.c	/^#define LOG_TAG /;"	d	file:
allow_isolated	service_manager.c	/^    int allow_isolated;$/;"	m	struct:svcinfo	file:
audit_callback	service_manager.c	/^static int audit_callback(void *data, security_class_t cls, char *buf, size_t len)$/;"	f	file:
check_mac_perms	service_manager.c	/^static bool check_mac_perms(pid_t spid, const char *tctx, const char *perm, const char *name)$/;"	f	file:
check_mac_perms_from_getcon	service_manager.c	/^static bool check_mac_perms_from_getcon(pid_t spid, const char *perm)$/;"	f	file:
check_mac_perms_from_lookup	service_manager.c	/^static bool check_mac_perms_from_lookup(pid_t spid, const char *perm, const char *name)$/;"	f	file:
death	service_manager.c	/^    struct binder_death death;$/;"	m	struct:svcinfo	typeref:struct:svcinfo::binder_death	file:
do_add_service	service_manager.c	/^int do_add_service(struct binder_state *bs,$/;"	f
do_find_service	service_manager.c	/^uint32_t do_find_service(struct binder_state *bs, const uint16_t *s, size_t len, uid_t uid, pid_t spid)$/;"	f
find_svc	service_manager.c	/^struct svcinfo *find_svc(const uint16_t *s16, size_t len)$/;"	f
handle	service_manager.c	/^    uint32_t handle;$/;"	m	struct:svcinfo	file:
len	service_manager.c	/^    size_t len;$/;"	m	struct:svcinfo	file:
main	service_manager.c	/^int main(int argc, char **argv)$/;"	f
name	service_manager.c	/^    uint16_t name[0];$/;"	m	struct:svcinfo	file:
next	service_manager.c	/^    struct svcinfo *next;$/;"	m	struct:svcinfo	typeref:struct:svcinfo::svcinfo	file:
sehandle	service_manager.c	/^static struct selabel_handle* sehandle;$/;"	v	typeref:struct:selabel_handle	file:
selinux_enabled	service_manager.c	/^static int selinux_enabled;$/;"	v	file:
service_manager_context	service_manager.c	/^static char *service_manager_context;$/;"	v	file:
str16eq	service_manager.c	/^int str16eq(const uint16_t *a, const char *b)$/;"	f
str8	service_manager.c	/^const char *str8(const uint16_t *x, size_t x_len)$/;"	f
svc_can_find	service_manager.c	/^static int svc_can_find(const uint16_t *name, size_t name_len, pid_t spid)$/;"	f	file:
svc_can_list	service_manager.c	/^static int svc_can_list(pid_t spid)$/;"	f	file:
svc_can_register	service_manager.c	/^static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid)$/;"	f	file:
svcinfo	service_manager.c	/^struct svcinfo$/;"	s	file:
svcinfo_death	service_manager.c	/^void svcinfo_death(struct binder_state *bs, void *ptr)$/;"	f
svclist	service_manager.c	/^struct svcinfo *svclist = NULL;$/;"	v	typeref:struct:svcinfo
svcmgr_id	service_manager.c	/^uint16_t svcmgr_id[] = {$/;"	v
